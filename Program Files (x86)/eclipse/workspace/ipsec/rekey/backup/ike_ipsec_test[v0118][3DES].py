
#! /usr/bin/env python
#############################################################################
##                                                                         ##
## This script is used to test IKEv2, it only support 3DES-CBC and SHA1-96 ##
## The difficulty is calculate keys                                        ##
##                                                                         ##
## Copyright (C) 2012  wukun  <wukun0451@gmail.com>                        ##
##                                                                         ##
##                                                                         ##
##                                                                         ##
## This program is free software; you can redistribute it and/or modify it ##
## under the terms of the GNU General Public License version 2 as          ##
## published by the Free Software Foundation; version 2.                   ##
##                                                                         ##
## This program is distributed in the hope that it will be useful, but     ##
## WITHOUT ANY WARRANTY; without even the implied warranty of              ##
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       ##
## General Public License for more details.                                ##
##                                                                         ##
#############################################################################

####### History #############################################################
## wukun @16/12/2013 -- 21/12/2013
##          - make a big change, add some functions
##          - add gen_create_child_sa_for_rekey_ike and gen_create_child_sa_for_rekey_ipsec function.
## wukun @09/09/2013
##          - add delete ike sa function.
##          - add delete ipsec sa function, should edit class IKEv2_payload_Delete in ikev2.py
##          - add variable "ike_message_id"
## wukun @09/06/2013
##          - add ike padding
##          - change ipsec_spi_i to a rand string which begins with '8888'
## wukun @09/05/2013
##          - change the flags of large packet from "0x02" to "0x00", 0x02: don't fragment.
## wukun @09/04/2013
##          - add keys log function
##          - add payload_padding function
##          - add support for PPPoE scanerio
## wukun @09/03/2013:
##          - discard the ISAKMKP packet whose init_spi is not equal to generated by the script self.
##          - add auto padding for ESP packet.
## wukun @10/12/2012:
##          - add timeout when no ESP packets received.
## wukun @28/12/2012:
##          - add dumped pcap filename operation
## wukun @12/12/2012: 
##          - export the decrypted ESP packets
## wukun @11/12/2012:
##          - add dissert_ikev2_decrypted_payload, after dissert ikev2 auth 
##            response message, we can get peer's esp initial vector
## wukun @09/15/2012: 
##          - start this script which based on PPPoE server scripts

from scapy.all import *
from Crypto.Cipher import DES3
from Crypto.Hash import HMAC
from Crypto.Hash import SHA

import inspect
import binascii
import string
import gmpy2
import os
import datetime
import struct


#select the right interface, you can use command "get_if_list()", "get_if_hwaddr('eth0')", "get_if_addr('eth0')" to lookup interface
conf.iface = "eth1"

test_pppoe_scenario = False

#get local interface's mac address
src_mac = get_if_hwaddr(conf.iface)
src_ip  = "10.69.196.184"
dst_ip  = "10.69.196.47"

if test_pppoe_scenario:
    dst_ip = "10.0.0.100"

traffic_selector_local_ip  = "10.69.196.100"
traffic_selector_remote_ip = "10.69.196.47"

# dst_mac = "18:03:73:1e:1b:2b"
# dst_mac = "00:0F:BB:64:F4:EE"
gateway_ip = "10.69.196.47"

if test_pppoe_scenario:
    gateway_ip = "10.69.196.125"

dst_mac = getmacbyip(gateway_ip)

ike_message_id = 0

s = conf.L2socket(iface = conf.iface, filter = "ip proto 50 or udp port 500 or udp port 4500")

def toHex(s):
    lst = []
    for ch in s:
        hv = hex(ord(ch)).replace('0x', '')
        if len(hv) == 1:
            hv = '0'+hv
        lst.append(hv)

    return reduce(lambda x,y:x+y, lst)
#convert hex repr to string
def toStr(s):
    return s and chr(string.atoi(s[:2], base=16)) + toStr(s[2:]) or ''

#convert ip to hex_str, for example, '192.168.1.150'->'c0a80196', it can be substituted with inet_aton
# def ip_2_hex_str(s):
    # lst = []
    # for i in s.split('.'):
        # hv = hex(int(i)).replace('0x', '')
        # if len(hv) == 1:
            # hv = '0'+hv
        # lst.append(hv)
    # return reduce(lambda x,y:x+y, lst)

'''Returns the current line number in our program.'''
def lineno():
    return inspect.currentframe().f_back.f_lineno

def gen_shared_dh_secret():
    # global g, p, xa, ya
    g = gmpy2.mpz('2')
    p = gmpy2.mpz('179769313486231590770839156793787453197860296048756011706444423684197180216158519368947833795864925541502180565485980503646440548199239100050792877003355816639229553136239076508735759914822574862575007425302077447712589550957937778424442426617334727629299387668709205606050270810842907692932019128194467627007')
    xa = gmpy2.mpz('49956553635759608382359867930274517260006950954448237256274964374712800745286606996193735932072025048582091900533082447058703490508462005754086856005422670597087911385947511126078946904021544457998333159002978816108515822152211762823274883616403401714654478697748253168858673631758117328317148256669260572969')
    ya = gmpy2.powmod(g, xa, p)
    # print "the decimal value of ya is \n" + ya.digits(10)
    # print "the hex value of ya is \n" + ya.digits(16)
    # ke_i = toStr('0000' + ya.digits(16))
    # hexdump(ke_i)
    return (g, p, xa, ya)

(g, p, xa, ya) = gen_shared_dh_secret()

ike_spi_i = ''.join(RandString(8))
print "line %d: ike_spi_i is \n%s" % (lineno(), toHex(ike_spi_i))
ike_nonce_i = ''.join(RandString(32))
print "line %d: ike_nonce_i is \n%s" % (lineno(), toHex(ike_nonce_i))

def gen_ikes_sa_init(ike_spi_i, ike_nonce_i, ya):
    global ike_message_id, message
    ike_sa_init = Ether()/IP()
    ike_sa_init[Ether].src = src_mac
    ike_sa_init[Ether].dst = dst_mac
    ike_sa_init[IP].src = src_ip
    ike_sa_init[IP].dst = dst_ip
    # ike_sa_init[IP].payload = ike_sa_init_example[0][IP].payload
    udp = UDP(sport = 500, dport = 500)
    ike_sa_init /= udp

    ikev2 = IKEv2()
    ikev2.init_SPI = ike_spi_i
    #ikev2.resp_SPI = 0
    ikev2.next_payload = IKEv2_payload_type.index("SA")
    ikev2.version = 0x20
    ikev2.exch_type = IKEv2_exchange_type.index("IKE_SA_INIT")
    ikev2.flags = 0x08
    ikev2.id     = ike_message_id
    ike_message_id += 1

    #construct payload transform and proposal
    ikev2_payload_transform_encryption = IKEv2_payload_Transform()
    ikev2_payload_transform_encryption.next_payload = 0x03
    ikev2_payload_transform_encryption.transform_type = 0x01   #encryption
    ikev2_payload_transform_encryption.transform_id = 0x0003     #3des

    ikev2_payload_transform_integrity = IKEv2_payload_Transform()
    ikev2_payload_transform_integrity.next_payload = 0x03
    ikev2_payload_transform_integrity.transform_type = 0x03     #integrity
    ikev2_payload_transform_integrity.transform_id = 0x0002

    ikev2_payload_transform_prf = IKEv2_payload_Transform()
    ikev2_payload_transform_prf.next_payload = 0x03
    ikev2_payload_transform_prf.transform_type = 0x02           #prf
    ikev2_payload_transform_prf.transform_id = 0x002

    ikev2_payload_transform_dhgroup = IKEv2_payload_Transform()
    ikev2_payload_transform_dhgroup.next_payload = 0x00         #no next payload in transform
    ikev2_payload_transform_dhgroup.transform_type = 0x04       #dh group
    ikev2_payload_transform_dhgroup.transform_id = 0x002

    #construct payload proposal
    ikev2_payload_proposal = IKEv2_payload_Proposal()
    ikev2_payload_proposal.next_payload = 0x0
    ikev2_payload_proposal.trans = ikev2_payload_transform_encryption/ikev2_payload_transform_integrity/ikev2_payload_transform_prf/ikev2_payload_transform_dhgroup
    ikev2_payload_proposal.trans_nb = 0x04      #the number of transform

    #construct payload key exchange
    ikev2_payload_ke = IKEv2_payload_KE()
    ikev2_payload_ke.next_payload = 0x28        #next payload is nonce
    ikev2_payload_ke.group = 0x0002             #1024-bit MODP group
    # ke_i = ''.join(RandString(128))
    # ikev2_payload_ke.load = '\x00\x00' + ya.digits(16)
    ikev2_payload_ke.load = toStr(ya.digits(16))

    #construct payload nonce
    ikev2_payload_nonce = IKEv2_payload_Nonce()
    ikev2_payload_nonce.next_payload = 0x00     #no more payload
    ikev2_payload_nonce.load = ike_nonce_i

    ikev2_payload_sa = IKEv2_payload_SA()
    ikev2_payload_sa.next_payload = 0x22        #next payload is key exchange
    ikev2_payload_sa.prop = ikev2_payload_proposal

    ikev2 /= ikev2_payload_sa/ikev2_payload_ke/ikev2_payload_nonce
    ike_sa_init /= ikev2

    message = ikev2.copy()
    s.send(ike_sa_init)

gen_ikes_sa_init(ike_spi_i, ike_nonce_i, ya)

while True:
    ike_sa_init = s.recv()
    if ike_sa_init is None or ike_sa_init[Ether].src == src_mac:
       continue
    #elif ike_sa_init[UDP].sport == 500 and ike_sa_init.init_SPI == ike_spi_i :
    elif ike_sa_init.haslayer("IKEv2") and ike_sa_init.init_SPI == ike_spi_i:
        # ike_sa_init.show2()
        ike_sa_init_r = ike_sa_init[IKEv2]          #it's used to caculate authentication data
        ike_spi_r = ike_sa_init[IKEv2].resp_SPI
        print "line %d: ike_spi_r is \n%s" % (lineno(), toHex(ike_spi_r))
        #yb is key payload of responder
        yb = ike_sa_init[IKEv2_payload_KE].load
        print "line %d: yb is \n%s" % (lineno(), toHex(yb))
        ike_nonce_r = ike_sa_init[IKEv2_payload_Nonce].load
        print "line %d: ike_nonce_r is \n%s" % (lineno(), toHex(ike_nonce_r))
        break


def gen_ike_key(xa, yb, ike_nonce_i, ike_nonce_r, ike_spi_i, ike_spi_r):
    yb = gmpy2.mpz(toHex(yb), 16)
    zz = gmpy2.powmod(yb, xa, p)
    zz = zz.digits(16)
    print "line %d: zz is \n%s" % (lineno(), zz)
    ni_and_nr = ike_nonce_i + ike_nonce_r
    print "line %d: ni_and_nr is \n%s" % (lineno(), toHex(ni_and_nr))

    # hmac_key    = binascii.a2b_hex(toHex(ni_and_nr))
    # hmac_data   = binascii.a2b_hex(zz)
    hmac_key    = ni_and_nr
    hmac_data   = toStr(zz)
    hmac        = HMAC.new(hmac_key, hmac_data, digestmod = SHA)
    skeyseed    = hmac.hexdigest()
    print "line %d: skeyseed is \n%s" % (lineno(), skeyseed)

    # { SK_d | SK_ai | SK_ar | SK_ei | SK_er |SK_pi | SK_pr } = prf+ (SKEYSEED, Ni | Nr | SPIi | SPIr)
    # prf_plus_seed = Ni | Nr | SPIi | SPIr
    # T1 = prf (SKEYSEED, prf_plus_seed | 0x01)  equals T1 = prf (SKEYSEED, '' | prf_plus_seed | 0x01)
    # T2 = prf (SKEYSEED, T1 | prf_plus_seed | 0x02)
    # T3 = prf (SKEYSEED, T2 | prf_plus_seed | 0x03)
    # T4 = prf (SKEYSEED, T3 | prf_plus_seed | 0x04)

    prf_plus_seed = ike_nonce_i + ike_nonce_r + ike_spi_i + ike_spi_r
    total_key_len = 20+20*2+24*2+20*2   #total_key_len = 148, every time hmac_sha1 generate 20Bytes data, so need run (148/20+1 = 8) times hmac_sha1
    n = '\x01'
    t = ''
    sk = ''
    hmac_key    = toStr(skeyseed)
    for x in range(1, 9):
        hmac_data = t + prf_plus_seed + n
        hmac = HMAC.new(hmac_key, hmac_data, SHA)
        t = toStr(hmac.hexdigest())
        n = chr(ord(n)+1)
        sk = sk + t
    print toHex(sk)

    SK_d    = sk[:20]
    SK_ai   = sk[len(SK_d):20+len(SK_d)]
    SK_ar   = sk[len(SK_ai+SK_d):20+len(SK_ai+SK_d)]
    SK_ei   = sk[len(SK_ar+SK_ar+SK_d):24+len(SK_ar+SK_ar+SK_d)]
    SK_er   = sk[len(SK_ei+SK_ar+SK_ar+SK_d):24+len(SK_ei+SK_ar+SK_ar+SK_d)]
    SK_pi   = sk[len(SK_er+SK_ei+SK_ar+SK_ar+SK_d):20+len(SK_er+SK_ei+SK_ar+SK_ar+SK_d)]
    SK_pr   = sk[len(SK_pi+SK_er+SK_ei+SK_ar+SK_ar+SK_d):20+len(SK_pi+SK_er+SK_ei+SK_ar+SK_ar+SK_d)]
    print "line %d: SK_d is \n%s"  %(lineno(), toHex(SK_d))
    print "line %d: SK_ai is \n%s" %(lineno(), toHex(SK_ai))
    print "line %d: SK_ar is \n%s" %(lineno(), toHex(SK_ar))
    print "line %d: SK_ei is \n%s" %(lineno(), toHex(SK_ei))
    print "line %d: SK_er is \n%s" %(lineno(), toHex(SK_er))
    print "line %d: SK_pi is \n%s" %(lineno(), toHex(SK_pi))
    print "line %d: SK_pr is \n%s" %(lineno(), toHex(SK_pr))

    return (SK_d, SK_ai, SK_ar, SK_ei, SK_er, SK_pi, SK_pr)

(SK_d, SK_ai, SK_ar, SK_ei, SK_er, SK_pi, SK_pr) = gen_ike_key(xa, yb, ike_nonce_i, ike_nonce_r, ike_spi_i, ike_spi_r)

def regen_ike_key(xa, yb, SK_d, ike_nonce_i, ike_nonce_r, ike_spi_i, ike_spi_r):
    yb = gmpy2.mpz(toHex(yb), 16)
    zz = gmpy2.powmod(yb, xa, p)
    zz = zz.digits(16)
    print "line %d: zz is \n%s" % (lineno(), zz)
    ni_and_nr = ike_nonce_i + ike_nonce_r
    print "line %d: ni_and_nr is \n%s" % (lineno(), toHex(ni_and_nr))

    # hmac_key    = binascii.a2b_hex(toHex(ni_and_nr))
    # hmac_data   = binascii.a2b_hex(zz)
    hmac_key    = SK_d
    hmac_data   = toStr(zz) + ni_and_nr
    hmac        = HMAC.new(hmac_key, hmac_data, digestmod = SHA)
    skeyseed    = hmac.hexdigest()
    print "line %d: skeyseed is \n%s" % (lineno(), skeyseed)

    # { SK_d | SK_ai | SK_ar | SK_ei | SK_er |SK_pi | SK_pr } = prf+ (SKEYSEED, Ni | Nr | SPIi | SPIr)
    # prf_plus_seed = Ni | Nr | SPIi | SPIr
    # T1 = prf (SKEYSEED, prf_plus_seed | 0x01)  equals T1 = prf (SKEYSEED, '' | prf_plus_seed | 0x01)
    # T2 = prf (SKEYSEED, T1 | prf_plus_seed | 0x02)
    # T3 = prf (SKEYSEED, T2 | prf_plus_seed | 0x03)
    # T4 = prf (SKEYSEED, T3 | prf_plus_seed | 0x04)

    prf_plus_seed = ike_nonce_i + ike_nonce_r + ike_spi_i + ike_spi_r
    total_key_len = 20+20*2+24*2+20*2   #total_key_len = 148, every time hmac_sha1 generate 20Bytes data, so need run (148/20+1 = 8) times hmac_sha1
    n = '\x01'
    t = ''
    sk = ''
    hmac_key    = toStr(skeyseed)
    for x in range(1, 9):
        hmac_data = t + prf_plus_seed + n
        hmac = HMAC.new(hmac_key, hmac_data, SHA)
        t = toStr(hmac.hexdigest())
        n = chr(ord(n)+1)
        sk = sk + t
    print toHex(sk)

    SK_d    = sk[:20]
    SK_ai   = sk[len(SK_d):20+len(SK_d)]
    SK_ar   = sk[len(SK_ai+SK_d):20+len(SK_ai+SK_d)]
    SK_ei   = sk[len(SK_ar+SK_ar+SK_d):24+len(SK_ar+SK_ar+SK_d)]
    SK_er   = sk[len(SK_ei+SK_ar+SK_ar+SK_d):24+len(SK_ei+SK_ar+SK_ar+SK_d)]
    SK_pi   = sk[len(SK_er+SK_ei+SK_ar+SK_ar+SK_d):20+len(SK_er+SK_ei+SK_ar+SK_ar+SK_d)]
    SK_pr   = sk[len(SK_pi+SK_er+SK_ei+SK_ar+SK_ar+SK_d):20+len(SK_pi+SK_er+SK_ei+SK_ar+SK_ar+SK_d)]
    print "line %d: SK_d is \n%s"  %(lineno(), toHex(SK_d))
    print "line %d: SK_ai is \n%s" %(lineno(), toHex(SK_ai))
    print "line %d: SK_ar is \n%s" %(lineno(), toHex(SK_ar))
    print "line %d: SK_ei is \n%s" %(lineno(), toHex(SK_ei))
    print "line %d: SK_er is \n%s" %(lineno(), toHex(SK_er))
    print "line %d: SK_pi is \n%s" %(lineno(), toHex(SK_pi))
    print "line %d: SK_pr is \n%s" %(lineno(), toHex(SK_pr))

    return (SK_d, SK_ai, SK_ar, SK_ei, SK_er, SK_pi, SK_pr)


# isakmp_sa_init_example = rdpcap("./isakmp_sa_init.pcap")

ike_auth = Ether()/IP()
# ike_auth[Ether].src = get_if_hwaddr(conf.iface)
ike_auth[Ether].src = src_mac
ike_auth[Ether].dst = dst_mac
ike_auth[IP].src = src_ip
ike_auth[IP].dst = dst_ip
# ike_auth[IP].payload = isakmp_sa_init_example[0][IP].payload
udp = UDP(sport = 500, dport = 500)
ike_auth /= udp

ikev2 = IKEv2()
# ikev2.init_SPI = ''.join(RandString(8))
ikev2.init_SPI = ike_spi_i
ikev2.resp_SPI = ike_spi_r

#ikev2.resp_SPI = 0
ikev2.next_payload = IKEv2_payload_type.index("Encrypted")
ikev2.version = 0x20
ikev2.exch_type = IKEv2_exchange_type.index("IKE_AUTH")
ikev2.flags = 0x08
# ikev2.id = 0x00000001
ikev2.id     = ike_message_id
ike_message_id += 1


init_vector = toStr('af3cd1900ee0d879')
# init_vector = ''.join(RandString(8))

'''
octets = message + nonce + prf(Sk_px, IDx')   
message is former constructed ike_sa_init
nonce   is ike_sa_init_responder's noce
SK_px   is caculated before
IDx     is '01000000'+ hex string of ip address
'''

# secret => 5 bytes @ 0x84d5690
# prf(secret, keypad) => 20 bytes @ 0x84e6740
# AUTH = prf(prf(secret, keypad), octets) => 20 bytes @ 0x84e71a0

# hmac_key        = toStr('663EF9C046B7234AA6FA10AADEA64752EA15DF6D')
hmac_key        = SK_pi
hmac_data       = "\x01\x00\x00\x00" + inet_aton(src_ip)
print "line %d: hmac_data is \n%s"  %(lineno(), toHex(hmac_data))
hmac            = HMAC.new(hmac_key, hmac_data, SHA)
prf_sk_px_idx   = hmac.hexdigest()
# print "line %d: prf_sk_px_idx is \n%s"  %(lineno(), prf_sk_px_idx)

psk         = "AAAA"                #authentication psk, password
hmac_key    = psk                       #it exists in /etc/ipsec.secret
hmac_data   = "Key Pad for IKEv2"   #based on RFC http://tools.ietf.org/html/rfc5996#page-87
hmac        = HMAC.new(hmac_key, hmac_data, SHA)
prf_shared_secret = hmac.hexdigest()
print "line %d: prf_shared_secret is \n%s"  %(lineno(), prf_shared_secret)

# packet = rdpcap("./ya yb xa xb p g.pcap")
# ikev2 = packet[0][IKEv2]
# ike_nonce_r = toStr('a80650192ca5a6b44159e69078a1449a84a17ae0beb4a7bf5d77cb7c3f174620')
octets      = str(message) + ike_nonce_r + toStr(prf_sk_px_idx)
print "line %d: ike_nonce_r is \n%s" % (lineno(), toHex(ike_nonce_r))
print "line %d: octets is \n%s"  %(lineno(), toHex(octets))
hmac_key    = prf_shared_secret
hmac_data   = octets
hmac        = HMAC.new(toStr(hmac_key), hmac_data, SHA)
auth_hmac_data  = hmac.hexdigest()
print "line %d: auth_hmac_data is \n%s"  %(lineno(), auth_hmac_data)

ikev2_payload_idi = IKEv2_payload_IDi()
ikev2_payload_idi.next_payload  = 0x27          #next payload is Authentication
ikev2_payload_idi.res       = 0x00              #RESERVERD
ikev2_payload_idi.IDtype    = 0x01              #IPV4_ADDR
ikev2_payload_idi.ProtoID   = 0x00              #Unused
ikev2_payload_idi.Port      = 0x0000            #Unused
ikev2_payload_idi.load      = inet_aton(src_ip)
# ikev2_payload_idi.load      = toStr(ip_2_hex_str(src_ip)) #change ip to string, for example, '192.168.1.150'->'c0a8196'
# ikev2_payload_idi.load      = toStr("c0a80196") #Identification Data

ikev2_payload_auth = IKEv2_payload_AUTH()
ikev2_payload_auth.next_payload = 0x21          #next payload is SA              
ikev2_payload_auth.res1 = 0x00                  #RESERVERD
ikev2_payload_auth.auth_method  = 0x02          #Shared Key Message Integrity Code
ikev2_payload_auth.res2 = 0x000000              #RESERVERD
ikev2_payload_auth.load = toStr(auth_hmac_data)        #Authentication Data
# ikev2_payload_auth.load = toStr('49a32dd13667eeb85cabe44461768885eafd7e87') #Authentication Data

#construct payload transform and proposal
ipsec_payload_transform_encryption = IKEv2_payload_Transform()
ipsec_payload_transform_encryption.next_payload = 0x03      #next payload is transform
ipsec_payload_transform_encryption.res  = 0x00              #RESERVERD
# ipsec_payload_transform_encryption.length = 0x08
ipsec_payload_transform_encryption.transform_type = 0x01    #encryption
ipsec_payload_transform_encryption.transform_id = 0x0003    #encr_3des

ipsec_payload_transform_integrity = IKEv2_payload_Transform()
ipsec_payload_transform_integrity.next_payload = 0x03       #next payload is transform
ipsec_payload_transform_integrity.res   = 0x00              #RESERVERD
ipsec_payload_transform_integrity.transform_type = 0x03     #integrity
ipsec_payload_transform_integrity.transform_id = 0x0002     #auth_hmac_sha1_96

ipsec_payload_transform_esn = IKEv2_payload_Transform()     #extended sequence numbers transform
ipsec_payload_transform_esn.next_payload = 0x00             #no next payload
ipsec_payload_transform_esn.res   = 0x00                    #RESERVERD
ipsec_payload_transform_esn.transform_type = 0x05           #extended sequence numbers
ipsec_payload_transform_esn.transform_id = 0x0000           #no extended sequence numbers

ipsec_payload_proposal = IPSec_payload_Proposal()
ipsec_payload_proposal.next_payload = 0x0                   #no next payload
ipsec_payload_proposal.res      = 0x00                      #RESERVERD
ipsec_payload_proposal.proposal = 0x01
ipsec_payload_proposal.proto    = 0x03                      #esp
ipsec_payload_proposal.SPIsize  = 0x04                      #spi size
ipsec_payload_proposal.trans_nb = 0x03                      #the number of transform
# ipsec_spi_i                     = toStr('88888888')
# ipsec_spi_i                     = toStr('8888' + str(random.randint(1000, 9999)))
ipsec_spi_i                     = '\x88\x88' + randstring(2)
ipsec_payload_proposal.SPI      = ipsec_spi_i               #spi
# ipsec_payload_proposal.SPI      = toStr('ccc65c69')         #spi
ipsec_payload_proposal.trans = ipsec_payload_transform_encryption/ipsec_payload_transform_integrity/ipsec_payload_transform_esn

ipsec_payload_sa = IKEv2_payload_SA()
ipsec_payload_sa.next_payload = 0x2c            #next payload is key exchange
ipsec_payload_sa.res    = 0x00                  #RESERVERD
ipsec_payload_sa.prop   = ipsec_payload_proposal

ikev2_payload_tsi = IKEv2_payload_TSi()
ikev2_payload_tsi.next_payload = 0x2d           #next payload is traffic selector responder
ikev2_payload_tsi.res1  = 0x00
ikev2_payload_tsi.ts_nb = 0x01
ikev2_payload_tsi.res2  = 0x000000
ikev2_payload_tsi.type  = 0x07
ikev2_payload_tsi.ProtoID   = 0x00
ikev2_payload_tsi.start_port= 0x0000
ikev2_payload_tsi.end_port  = 0xffff
ikev2_payload_tsi.start_addr= traffic_selector_local_ip
ikev2_payload_tsi.end_addr  = traffic_selector_local_ip
# hexdump(ikev2_payload_tsi)

ikev2_payload_tsr = IKEv2_payload_TSr()
ikev2_payload_tsr.next_payload = 0x29           #next payload is traffic selector responder
ikev2_payload_tsr.res1  = 0x00
ikev2_payload_tsr.ts_nb = 0x01
ikev2_payload_tsr.res2  = 0x000000
ikev2_payload_tsr.type  = 0x07
ikev2_payload_tsr.ProtoID   = 0x00
ikev2_payload_tsr.start_port= 0x0000
ikev2_payload_tsr.end_port  = 0xffff
ikev2_payload_tsr.start_addr= traffic_selector_remote_ip
ikev2_payload_tsr.end_addr  = traffic_selector_remote_ip
# hexdump(ikev2_payload_tsr)

ike_auth_payload_notify_1 = IKEv2_payload_Notify()
ike_auth_payload_notify_1.next_payload = 0x29     #next payload is notify
ike_auth_payload_notify_1.res  = 0x00             #RESERVERD
ike_auth_payload_notify_1.ProtoID = 0x00          #protocol id
ike_auth_payload_notify_1.SPIsize = 0x00          #spi size
ike_auth_payload_notify_1.type = 0x4014           #multiple_auth_supported
ike_auth_payload_notify_1.load = ""
# hexdump(ike_auth_payload_notify_1)

ike_auth_payload_notify_2 = IKEv2_payload_Notify()
ike_auth_payload_notify_2.next_payload = 0x00     #no next payload
ike_auth_payload_notify_2.res  = 0x00             #RESERVERD
ike_auth_payload_notify_2.ProtoID = 0x00          #protocol id
ike_auth_payload_notify_2.SPIsize = 0x00          #spi size
ike_auth_payload_notify_2.type = 0x4021           #eap_only_authentication
ike_auth_payload_notify_2.load = ""
# hexdump(ike_auth_payload_notify_2)

# padding = toStr("4c63105f3b5b5f07")               #the padding has contains the pad length(07)

# plain_data = str(ikev2_payload_idi)+str(ikev2_payload_auth)+str(ipsec_payload_sa)+str(ikev2_payload_tsi)+str(ikev2_payload_tsr)+str(ike_auth_payload_notify_1)+str(ike_auth_payload_notify_2)+str(padding)
plain_data = str(ikev2_payload_idi)+str(ikev2_payload_auth)+str(ipsec_payload_sa)+str(ikev2_payload_tsi)+str(ikev2_payload_tsr)+str(ike_auth_payload_notify_1)+str(ike_auth_payload_notify_2)

ike_padding = ''
ike_pad_len = 0
if (len(plain_data) + 1)%8 == 0:
    ike_padding = '\x00'
else:
    ike_pad_len = ((len(plain_data) + 1)/8 + 1 )*8 - (len(plain_data) + 1)
    ike_padding = ''.join(randstring(ike_pad_len)) + chr(ike_pad_len)

plain_data += ike_padding

print "line %d: plain_data is \n%s" % (lineno(), toHex(plain_data))
print "line %d: plain_data is \n%s" % (lineno(), toHex(init_vector))
des3_encrypt = DES3.new(SK_ei, DES3.MODE_CBC, init_vector)
encrypted_data = des3_encrypt.encrypt(plain_data)
print "line %d: encrypted_data is \n%s" % (lineno(), toHex(encrypted_data))


ikev2_payload_encrypted = IKEv2_payload_Encrypted()
ikev2_payload_encrypted.next_payload = IKEv2_payload_type.index('IDi')  #next payload is Identification - Initiator
ikev2_payload_encrypted.res  = 0x00         #reserved
ikev2_payload_encrypted.iv   = init_vector  #initialation vector    
ikev2_payload_encrypted.load = encrypted_data + '\x00'*12   #first padding the integrity checksum data with '\x00'*12           
# ikev2_payload_encrypted.length = 176
# ikev2_payload_encrypted.load = encrypted_data + toStr(hmac_result)  #it contains encryted data and integrity checksum data



# hmac_key=toStr('29E2DB04354BDE118EEAE565EF57932974B6D795')
# hmac_data = toStr('0262c01228ad89b70a43b7b618eae1872e20230800000001000000cc230000b0af3cd1900ee0d879ca994e2dc531fd6404861e6e88599509ca5f4b7efed658f1bc13d04a3f16dcb812c95a1b51115230011e4cf6dc2b4fab088b7a57633ff9bec1d5f13fcf2f168e4e6d77cf78ae150c5e98bf9cb0b5b5f7de432cb61b6e7519347fdfac6ce745b4ecd48431e7971b21f70c4bddb4d9fb6a5eea6d5675f82398a1ea6e6384b0300bb64a43ded3ef226cce04c609ef3f9ba0f60b8ad466d61881')
hmac_key = SK_ai
hmac_data = str(ikev2/ikev2_payload_encrypted)[:-12]
hmac = HMAC.new(hmac_key, msg = hmac_data, digestmod = SHA)
hmac_result = hmac.hexdigest()[:24]
print "line %d: hmac_result is \n%s" % (lineno(), (hmac_result))
ikev2_payload_encrypted.load = encrypted_data + toStr(hmac_result)
print "line %d: ikev2_payload_encrypted.load is \n%s" % (lineno(), toHex(ikev2_payload_encrypted.load))
print "line %d: ikev2_payload_encrypted.load\'s length is \n%s" % (lineno(), len(ikev2_payload_encrypted.load))


ike_auth /= ikev2/ikev2_payload_encrypted
s.send(ike_auth)


def dissert_ikev2_decrypted_payload(type_index, raw_str_payload):
    ikev2_payload_decrypted = IKEv2_payload_Decrypted(next_payload=IKEv2_payload_type.index(type_index))
    position    = 0
    payload_type= []
    payload     = []
    payload_type.append(ikev2_payload_decrypted.next_payload)

    while position < len(str(raw_str_payload)):
        payload_len = int(toHex(raw_str_payload[position + 2:position + 4]), 16)
        payload.append(raw_str_payload[position:position+payload_len])
        t = int(toHex(raw_str_payload[position:position+1]), 16)
        payload_type.append(t)
        if t == 0:
            break;
        position += payload_len

    def class_for_name(module_name, class_name):
        # load the module, will raise ImportError if module cannot be loaded
        m = __import__(module_name, globals(), locals(), class_name)
        # get the class, will raise AttributeError if class cannot be found
        c = getattr(m, class_name)
        return c


    def str_2_payload(t, p):
        pt = IKEv2_payload_type[t]
        loaded_class = class_for_name('scapy.layers.ikev2', 'IKEv2_payload_%s' % pt)
        #print loaded_class
        return loaded_class(p)

    for t, p in zip(payload_type, payload):
        ikev2_payload_decrypted /= str_2_payload(t, p)
    
    return ikev2_payload_decrypted

while True:
    ike_auth_r = s.recv()
    if ike_auth_r is None or ike_auth_r[Ether].src == src_mac:
       continue
    # elif ike_auth_r[UDP].sport == 500 and ike_auth_r.init_SPI == ike_spi_i:
    elif ike_auth_r.haslayer("IKEv2") and ike_auth_r.exch_type == 0x23:
        # ike_auth_r.show2()
        init_vector_r   = ike_auth_r[IKEv2_payload_Encrypted].iv
        des3_decrypt = DES3.new(SK_er, DES3.MODE_CBC, init_vector_r)
        decrypted_data = des3_decrypt.decrypt((ike_auth_r[IKEv2_payload_Encrypted].load)[:-12])
        # ikev2_payload_decrypted = IKEv2_payload_Decrypted(next_payload=IKEv2_payload_type.index('IDi'))
        # ikev2_payload_decrypted /= decrypted_data


        ikev2_payload_decrypted = dissert_ikev2_decrypted_payload("IDi", decrypted_data)
        # ikev2.show2()
        # ikev2[IKEv2_payload_AUTH].show2()
        print "line %d: ipsec_spi_r is %s" %(lineno(), toHex(ikev2_payload_decrypted[IKEv2_payload_Proposal].SPI))
        # ikev2_payload_decrypted.show2()

        # ike_auth_r.show2()
        ipsec_spi_r = ikev2_payload_decrypted[IKEv2_payload_Proposal].SPI
        break

def gen_ipsec_key(ipsec_nonce_i, ipsec_nonce_r):
    # global SK_ai_ipsec, SK_ar_ipsec, SK_ei_ipsec, SK_er_ipsec, ipsec_spi_i, ipsec_spi_r
    prf_plus_seed = ipsec_nonce_i + ipsec_nonce_r
    total_key_len = 24+20+24+20   #total_key_len = 88, every time hmac_sha1 generate 20Bytes data, so need run (88/20+1 = 5) times hmac_sha1
    n = '\x01'
    t = ''
    sk = ''
    hmac_key    = SK_d
    for x in range(1, 6):
        hmac_data = t + prf_plus_seed + n
        hmac = HMAC.new(hmac_key, hmac_data, SHA)
        t = toStr(hmac.hexdigest())
        n = chr(ord(n)+1)
        sk = sk + t
    print "line %d: SK_ei_ipsec is \n%s" %(lineno(), toHex(sk))

    SK_ei_ipsec = sk[:24]
    SK_ai_ipsec = sk[len(SK_ei_ipsec):20+len(SK_ei_ipsec)]
    SK_er_ipsec   = sk[len(SK_ei_ipsec+SK_ai_ipsec):24+len(SK_ei_ipsec+SK_ai_ipsec)]
    SK_ar_ipsec   = sk[len(SK_ei_ipsec+SK_ai_ipsec+SK_er_ipsec):20+len(SK_ei_ipsec+SK_ai_ipsec+SK_er_ipsec)]

    print "line %d: SK_ei_ipsec is \n%s" %(lineno(), toHex(SK_ei_ipsec))
    print "line %d: SK_ai_ipsec is \n%s" %(lineno(), toHex(SK_ai_ipsec))
    print "line %d: SK_er_ipsec is \n%s" %(lineno(), toHex(SK_er_ipsec))
    print "line %d: SK_ar_ipsec is \n%s" %(lineno(), toHex(SK_ar_ipsec))
    print "the ipsec_spi_i is %s\n" % toHex(ipsec_spi_i)
    print "the ipsec_spi_r is %s\n" % toHex(ipsec_spi_r)
    ipsec_sad = {'IPV4' : [[src_ip, dst_ip, int(toHex(ipsec_spi_r), 16), 'ESP', '3DES-CBC', SK_ei_ipsec, 'HMAC-SHA1-96', SK_ai_ipsec],
                           [dst_ip, src_ip, int(toHex(ipsec_spi_i), 16), 'ESP', '3DES-CBC', SK_er_ipsec, 'HMAC-SHA1-96', SK_ar_ipsec]
                          ],
                 'IPV6' : [['*','3ffe::1','*','ESP','NULL','','NULL','']
                          ]
                }
    conf.setkey = IPSEC_SAD(ipsec_sad)
    print conf.setkey
    return (SK_ai_ipsec, SK_ar_ipsec, SK_ei_ipsec, SK_er_ipsec)


'''keys log'''
def save_keys_log(ike_spi_i, ike_spi_r, SK_ai, SK_ar, SK_ei, SK_er, SK_ai_ipsec, SK_ar_ipsec, SK_ei_ipsec, SK_er_ipsec):
    keys_log_file_name = "C:\\Scapy Log\\keys.log"
    keys_log_file = open(keys_log_file_name, "a")
    ike_encrypt_string = "3DES [RFC2451]"
    ike_authentication_string = "HMAC_SHA1_96 [RFC2404]"
    ipsec_encrypt_string = "TripleDES-CBC [RFC2451]"
    ipsec_authentication_string = "HMAC-SHA-1-96 [RFC2404]"
    keys_log_file.write('%s,%s,%s,%s,"%s",%s,%s,"%s"\n' % (toHex(ike_spi_i), toHex(ike_spi_r), toHex(SK_ei), toHex(SK_er), ike_encrypt_string, toHex(SK_ai), toHex(SK_ar), ike_authentication_string))
    keys_log_file.write('"%s","%s","%s","0x%s","%s","0x%s","%s","0x%s"\n' % ("IPv4", src_ip, dst_ip, toHex(ipsec_spi_r), ipsec_encrypt_string, toHex(SK_ei_ipsec), ipsec_authentication_string, toHex(SK_ai_ipsec)))
    keys_log_file.write('"%s","%s","%s","0x%s","%s","0x%s","%s","0x%s"\n' % ("IPv4", dst_ip, src_ip, toHex(ipsec_spi_i), ipsec_encrypt_string, toHex(SK_er_ipsec), ipsec_authentication_string, toHex(SK_ar_ipsec)))
    keys_log_file.close()


'''
   0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Security Parameters Index (SPI)                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Sequence Number                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---
   |                    IV (optional)                              | ^ p
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a
   |                    Rest of Payload Data  (variable)           | | y
   ~                                                               ~ | l
   |                                                               | | o
   +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a
   |               |         TFC Padding * (optional, variable)    | v d
   +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---
   |                         |        Padding (0-255 bytes)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               |  Pad Length   | Next Header   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Integrity Check Value-ICV   (variable)                |
   ~                                                               ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               Figure 2. Substructure of Payload Data

1500 byte packet becomes 1552 bytes:
    20 bytes IPsec header (tunnel mode)
    4 bytes SPI (ESP header)
    4 bytes Sequence (ESP Header)
    8 byte IV (IOS ESP-DES/3DES)
    2 byte pad (ESP-DES/3DES 64 bit)        Padding MAY contain any value chosen by the sender, and MUST have
                                            a length that makes the combination of the payloads, the Padding,
                                            and the Pad Length to be a multiple of the encryption block size.
                                            In this example, (1500+2) is not multiple of 8(3des block size), 
                                            so should be padding 2 bytes, than (1500+2+2)/8 = 188.
    1 byte Pad length (ESP Trailer)
    1 byte Next Header (ESP Trailer)
    12 bytes ESP MD5 96 digest
'''


'''Padding'''
def payload_padding(packet_len):
    pad_len = 0
    if (packet_len + 2)%8 == 0:            # the other 2 bytes ESP Trailer which continas "Pad Length" and "Next Header", refer the upper "Substructure of Payload Data"
        pad_len = 0
    else:
        pad_len = ((packet_len + 2)/8 + 1 )*8 - (packet_len + 2)

    print "len(icmp) is %d, pad_len is %d\n" % (packet_len, pad_len)

    pad_str = ''
    for i in xrange(1, pad_len+1):
        pad_str += chr(i)

    return pad_str


'''send ISAKMP INFORMATIONAL Delete Message(Delete IPSec sa)'''
def del_ipsec_sa(ike_spi_i, ike_spi_r, ipsec_spi_i, SK_ai, SK_ei):
    print "line %d: del_ipsec_sa" % lineno()
# if test_send_delete_ipsec_sa:
    global ike_message_id
    ikev2_ipsec_sa_delete = Ether()/IP()
    ikev2_ipsec_sa_delete[Ether].src = get_if_hwaddr(conf.iface)
    ikev2_ipsec_sa_delete[Ether].dst = dst_mac
    ikev2_ipsec_sa_delete[IP].src = src_ip
    ikev2_ipsec_sa_delete[IP].dst = dst_ip
    udp = UDP(sport = 500, dport = 500)
    ikev2_ipsec_sa_delete /= udp

    ikev2 = IKEv2()
    ikev2.init_SPI = ike_spi_i
    ikev2.resp_SPI = ike_spi_r
    ikev2.next_payload = IKEv2_payload_type.index("Encrypted")
    ikev2.version = 0x20
    ikev2.exch_type = IKEv2_exchange_type.index("INFORMATIONAL")
    ikev2.flags = 0x08
    ikev2.id     = ike_message_id
    ike_message_id += 1


    ikev2_payload_delete = IKEv2_payload_Delete()
    ikev2_payload_delete.next_payload = 0x00          #no next payload
    ikev2_payload_delete.res = 0x00                  #RESERVERD
    # ikev2_payload_delete.length = 0x08
    ikev2_payload_delete.protocol_id = 0x03
    ikev2_payload_delete.spi_size    = 0x04
    ikev2_payload_delete.spi_num     = 0x01

    #first convert long integer to string, then convert string to hex string. '4141'--> 0x4141--->'\x41\x41'
    # ipsec_spi_i_str = toHex(struct.unpack(">l", int(ipsec_spi_i, 16)))
    ikev2_payload_delete.spi_index   =  ipsec_spi_i

    # print "line %d: ipsec_spi_i is \n%s" % (lineno(), toHex(ipsec_spi_i_str))
    '''if the definition of field spi_index in ikev2.py is FieldListField, then the following code should change to ikev2_payload_delete.spi_index[0]'''
    print "line %d: ikev2_payload_delete.spi_index is \n%s" % (lineno(), toHex(ikev2_payload_delete.spi_index))

    # ikev2_payload_delete = IKEv2_payload_Delete(next_payload = 0x00, res = 0x00, protocol_id = 0x03, spi_size = 0x04, spi_num =  0x00, spi_index = ''.join(randstring(4)))
    # ikev2_payload_delete.show2()

    plain_data = str(ikev2_payload_delete)
    ike_padding = ''
    ike_pad_len = 0
    if (len(plain_data) + 1)%8 == 0:
        ike_padding = '\x00'
    else:
        ike_pad_len = ((len(plain_data) + 1)/8 + 1 )*8 - (len(plain_data) + 1)
        ike_padding = ''.join(randstring(ike_pad_len)) + chr(ike_pad_len)

    print "line %d: ike_pad_len is %d, ike_padding is \n%s" % (lineno(), ike_pad_len, toHex(ike_padding))

    plain_data += ike_padding
    des3_encrypt = DES3.new(SK_ei, DES3.MODE_CBC, init_vector)
    encrypted_data = des3_encrypt.encrypt(plain_data)
    # print "line %d: plain_data is \n%s" % (lineno(), toHex(plain_data))
    # print "line %d: SK_ei is \n%s" % (lineno(), toHex(SK_ei))
    # print "line %d: init_vector is \n%s" % (lineno(), toHex(init_vector))
    # print "line %d: encrypted_data is \n%s" % (lineno(), toHex(encrypted_data))

    # des3_encrypt = DES3.new(SK_ei, DES3.MODE_CBC, init_vector)
    # plain_data = des3_encrypt.decrypt(encrypted_data)
    # print "line %d: plain_data is \n%s" % (lineno(), toHex(plain_data))

    ikev2_payload_encrypted = IKEv2_payload_Encrypted()
    ikev2_payload_encrypted.next_payload = IKEv2_payload_type.index('Delete')  #next payload is Delete
    ikev2_payload_encrypted.res  = 0x00         #reserved
    ikev2_payload_encrypted.iv   = init_vector  #initialation vector    
    ikev2_payload_encrypted.load = encrypted_data + '\x00'*12   #first padding the integrity checksum data with '\x00'*12

    hmac_key = SK_ai
    hmac_data = str(ikev2/ikev2_payload_encrypted)[:-12]
    hmac = HMAC.new(hmac_key, msg = hmac_data, digestmod = SHA)
    hmac_result = hmac.hexdigest()[:24]

    ikev2_payload_encrypted.load = encrypted_data + toStr(hmac_result)
    ikev2_ipsec_sa_delete /= ikev2/ikev2_payload_encrypted

    # print "line %d: hmac_key is \n%s" % (lineno(), toHex(hmac_key))
    # print "line %d: hmac_result is \n%s" % (lineno(), hmac_result)
    # print "line %d: encrypted_data is \n%s" % (lineno(), toHex(encrypted_data))
    # print "line %d: ikev2_payload_encrypted is \n%s" % (lineno(), toHex(str(ikev2_payload_encrypted)))
    # print "line %d: ikev2/ikev2_payload_encrypted is \n%s" % (lineno(), toHex(str(ikev2/ikev2_payload_encrypted)))
    # print "line %d: ikev2_delete is \n%s" % (lineno(), toHex(str(ikev2_delete)) )

    s.send(ikev2_ipsec_sa_delete)
    print "line %d: del_ipsec_sa" % lineno()


'''send ISAKMP INFORMATIONAL Delete Message(Delete IKE sa)'''
def del_ike_sa(ike_spi_i, ike_spi_r, SK_ai, SK_ei):
    global ike_message_id
    init_vector = ''.join(RandString(8))

    ikev2_sa_delete = Ether()/IP()
    ikev2_sa_delete[Ether].src = src_mac
    ikev2_sa_delete[Ether].dst = dst_mac
    ikev2_sa_delete[IP].src = src_ip
    ikev2_sa_delete[IP].dst = dst_ip
    udp = UDP(sport = 500, dport = 500)
    ikev2_sa_delete /= udp

    ikev2 = IKEv2()
    ikev2.init_SPI = ike_spi_i
    ikev2.resp_SPI = ike_spi_r
    ikev2.next_payload = IKEv2_payload_type.index("Encrypted")
    ikev2.version = 0x20
    ikev2.exch_type = IKEv2_exchange_type.index("INFORMATIONAL")
    ikev2.flags = 0x08                            # ike initial message
    # ikev2.id = 0x00000003                        # ike message id
    ikev2.id     = ike_message_id
    ike_message_id += 1

    ikev2_payload_delete = IKEv2_payload_Delete()
    ikev2_payload_delete.next_payload = 0x00          #no next payload
    ikev2_payload_delete.res = 0x00                  #RESERVERD
    ikev2_payload_delete.protocol_id = 0x01
    ikev2_payload_delete.spi_size    = 0x00

    plain_data = str(ikev2_payload_delete)
    ike_padding = ''
    ike_pad_len = 0
    if (len(plain_data) + 1)%8 == 0:
        ike_padding = '\x00'
    else:
        ike_pad_len = ((len(plain_data) + 1)/8 + 1 )*8 - (len(plain_data) + 1)
        ike_padding = ''.join(randstring(ike_pad_len)) + chr(ike_pad_len)

    print "line %d: ike_pad_len is %d, ike_padding is \n%s" % (lineno(), ike_pad_len, toHex(ike_padding))

    plain_data += ike_padding

    print "line %d: plain_data is \n%s" % (lineno(), toHex(plain_data))
    des3_encrypt = DES3.new(SK_ei, DES3.MODE_CBC, init_vector)
    encrypted_data = des3_encrypt.encrypt(plain_data)
    print "line %d: encrypted_data is \n%s" % (lineno(), toHex(encrypted_data))


    ikev2_payload_encrypted = IKEv2_payload_Encrypted()
    ikev2_payload_encrypted.next_payload = IKEv2_payload_type.index('Delete')  #next payload is Delete
    ikev2_payload_encrypted.res  = 0x00         #reserved
    ikev2_payload_encrypted.iv   = init_vector  #initialation vector    
    ikev2_payload_encrypted.load = encrypted_data + '\x00'*12   #first padding the integrity checksum data with '\x00'*12

    hmac_key = SK_ai
    hmac_data = str(ikev2/ikev2_payload_encrypted)[:-12]
    hmac = HMAC.new(hmac_key, msg = hmac_data, digestmod = SHA)
    hmac_result = hmac.hexdigest()[:24]

    ikev2_payload_encrypted.load = encrypted_data + toStr(hmac_result)
    ikev2_sa_delete /= ikev2/ikev2_payload_encrypted
    s.send(ikev2_sa_delete)
    print "line %d: send ikev2_sa_delete complete" % (lineno())

def gen_create_child__sa_for_rekey_ipsec(ipsec_spi_i, SK_ai, SK_ar, SK_ei, SK_er):
    global ike_message_id
    ike_create_child_sa = Ether()/IP()
    ike_create_child_sa[Ether].src = src_mac
    ike_create_child_sa[Ether].dst = dst_mac
    ike_create_child_sa[IP].src = src_ip
    ike_create_child_sa[IP].dst = dst_ip
    udp = UDP(sport = 500, dport = 500)
    ike_create_child_sa /= udp

    ikev2 = IKEv2()
    # ikev2.init_SPI = ''.join(RandString(8))
    ikev2.init_SPI = ike_spi_i
    ikev2.resp_SPI = ike_spi_r

    #ikev2.resp_SPI = 0
    ikev2.next_payload = IKEv2_payload_type.index("Encrypted")
    ikev2.version = 0x20
    ikev2.exch_type = IKEv2_exchange_type.index("CREATE_CHILD_SA")
    # ikev2.exch_type = IKEv2_exchange_type.index("IKE_AUTH")
    ikev2.flags = 0x08
    # ikev2.id = 0x00000001
    # ike_message_id = 0x00
    ikev2.id     = ike_message_id
    ike_message_id += 1

    init_vector = ''.join(RandString(8))

    # packet = rdpcap("./ya yb xa xb p g.pcap")
    # ikev2 = packet[0][IKEv2]
    # ike_nonce_r = toStr('a80650192ca5a6b44159e69078a1449a84a17ae0beb4a7bf5d77cb7c3f174620')

    ikev2_payload_notify = IKEv2_payload_Notify()
    ikev2_payload_notify.next_payload  = 0x21          #next payload is Security Association
    ikev2_payload_notify.res       = 0x00              #RESERVERD
    ikev2_payload_notify.ProtoID   = 0x03              #ESP
    ikev2_payload_notify.SPIsize   = 0x04              #4Bytes
    ikev2_payload_notify.type      = 0x4009
    ikev2_payload_notify.SPI       = ipsec_spi_i
    # ikev2_payload_notify.show2()
    # hexdump(ikev2_payload_notify)


    #construct payload transform and proposal
    ipsec_payload_transform_encryption = IKEv2_payload_Transform()
    ipsec_payload_transform_encryption.next_payload = 0x03      #next payload is transform
    ipsec_payload_transform_encryption.res  = 0x00              #RESERVERD
    ipsec_payload_transform_encryption.transform_type = 0x01    #encryption
    ipsec_payload_transform_encryption.transform_id = 0x0003    #encr_3des

    ipsec_payload_transform_integrity = IKEv2_payload_Transform()
    ipsec_payload_transform_integrity.next_payload = 0x03       #next payload is transform
    ipsec_payload_transform_integrity.res   = 0x00              #RESERVERD
    ipsec_payload_transform_integrity.transform_type = 0x03     #integrity
    ipsec_payload_transform_integrity.transform_id = 0x0002     #auth_hmac_sha1_96

    ipsec_payload_transform_esn = IKEv2_payload_Transform()     #extended sequence numbers transform
    ipsec_payload_transform_esn.next_payload = 0x00             #no next payload
    ipsec_payload_transform_esn.res   = 0x00                    #RESERVERD
    ipsec_payload_transform_esn.transform_type = 0x05           #extended sequence numbers
    ipsec_payload_transform_esn.transform_id = 0x0000           #no extended sequence numbers

    ipsec_payload_proposal = IPSec_payload_Proposal()
    ipsec_payload_proposal.next_payload = 0x0                   #no next payload
    ipsec_payload_proposal.res      = 0x00                      #RESERVERD
    ipsec_payload_proposal.proposal = 0x01
    ipsec_payload_proposal.proto    = 0x03                      #esp
    ipsec_payload_proposal.SPIsize  = 0x04                      #spi size
    ipsec_payload_proposal.trans_nb = 0x03                      #the number of transform
    # ipsec_spi_i                     = toStr('88888888')
    # ipsec_spi_i                     = toStr('8888' + str(random.randint(1000, 9999)))
    ipsec_spi_i                     = '\x88\x88' + randstring(2)
    ipsec_payload_proposal.SPI      = ipsec_spi_i               #spi
    # ipsec_payload_proposal.SPI      = toStr('ccc65c69')         #spi
    ipsec_payload_proposal.trans = ipsec_payload_transform_encryption/ipsec_payload_transform_integrity/ipsec_payload_transform_esn

    ipsec_payload_sa = IKEv2_payload_SA()
    ipsec_payload_sa.next_payload = 0x28            #next payload is nonce
    ipsec_payload_sa.res    = 0x00                  #RESERVERD
    ipsec_payload_sa.prop   = ipsec_payload_proposal
    # ipsec_payload_sa.show2()
    # hexdump(ipsec_payload_sa)

    ikev2_payload_nonce = IKEv2_payload_Nonce()
    ikev2_payload_nonce.next_payload = 0x2c         #next payload is traffic selector initiator
    ipsec_nonce_i = ''.join(RandString(32))
    print "line %d: ipsec_nonce_i is \n%s" % (lineno(), toHex(ipsec_nonce_i))
    ikev2_payload_nonce.load = ipsec_nonce_i

    ikev2_payload_tsi = IKEv2_payload_TSi()
    ikev2_payload_tsi.next_payload = 0x2d           #next payload is traffic selector responder
    ikev2_payload_tsi.res1  = 0x00
    ikev2_payload_tsi.ts_nb = 0x01
    ikev2_payload_tsi.res2  = 0x000000
    ikev2_payload_tsi.type  = 0x07
    ikev2_payload_tsi.ProtoID   = 0x00
    ikev2_payload_tsi.start_port= 0x0000
    ikev2_payload_tsi.end_port  = 0xffff
    ikev2_payload_tsi.start_addr= traffic_selector_local_ip
    ikev2_payload_tsi.end_addr  = traffic_selector_local_ip
    # hexdump(ikev2_payload_tsi)

    ikev2_payload_tsr = IKEv2_payload_TSr()
    ikev2_payload_tsr.next_payload = 0x00           #no more payload
    ikev2_payload_tsr.res1  = 0x00
    ikev2_payload_tsr.ts_nb = 0x01
    ikev2_payload_tsr.res2  = 0x000000
    ikev2_payload_tsr.type  = 0x07
    ikev2_payload_tsr.ProtoID   = 0x00
    ikev2_payload_tsr.start_port= 0x0000
    ikev2_payload_tsr.end_port  = 0xffff
    ikev2_payload_tsr.start_addr= traffic_selector_remote_ip
    ikev2_payload_tsr.end_addr  = traffic_selector_remote_ip
    # hexdump(ikev2_payload_tsr)

    plain_data = str(ikev2_payload_notify)+str(ipsec_payload_sa)+str(ikev2_payload_nonce)+str(ikev2_payload_tsi)+str(ikev2_payload_tsr)


    ike_padding = ''
    ike_pad_len = 0
    if (len(plain_data) + 1)%8 == 0:
        ike_padding = '\x00'
    else:
        ike_pad_len = ((len(plain_data) + 1)/8 + 1 )*8 - (len(plain_data) + 1)
        ike_padding = ''.join(randstring(ike_pad_len)) + chr(ike_pad_len)

    plain_data += ike_padding

    # plain_data = toStr("2100000c03044009c124a413280000280000002401030403c1a0e60d0300000801000003030000080300000200000008050000002c0000243567abae7306de87335b3133ccf1aa6e52c3b73de9cd0767713f47fb288debda2d00001801000000070000100000ffff0a45c4000a45c4ff0000001801000000070000100000ffff0a45c42f0a45c42fc3660ef4bc4dad07")

    print "line %d: plain_data is \n%s" % (lineno(), toHex(plain_data))
    des3_encrypt = DES3.new(SK_ei, DES3.MODE_CBC, init_vector)
    encrypted_data = des3_encrypt.encrypt(plain_data)
    print "line %d: encrypted_data is \n%s" % (lineno(), toHex(encrypted_data))


    ikev2_payload_encrypted = IKEv2_payload_Encrypted()
    ikev2_payload_encrypted.next_payload = IKEv2_payload_type.index('Notify')  #next payload is Identification - Initiator
    ikev2_payload_encrypted.res  = 0x00         #reserved
    ikev2_payload_encrypted.iv   = init_vector  #initialation vector    
    ikev2_payload_encrypted.load = encrypted_data + '\x00'*12   #first padding the integrity checksum data with '\x00'*12
    # ikev2_payload_encrypted.load = encrypted_data + toStr(hmac_result)  #it contains encryted data and integrity checksum data

    hmac_key = SK_ai
    hmac_data = str(ikev2/ikev2_payload_encrypted)[:-12]
    hmac = HMAC.new(hmac_key, msg = hmac_data, digestmod = SHA)
    hmac_result = hmac.hexdigest()[:24]
    print "line %d: hmac_result is \n%s" % (lineno(), (hmac_result))
    ikev2_payload_encrypted.load = encrypted_data + toStr(hmac_result)

    print "line %d: SK_ei is \n%s" %(lineno(), toHex(SK_ei))
    print "line %d: SK_ai is \n%s" %(lineno(), toHex(SK_ai))

    ike_create_child_sa /= ikev2/ikev2_payload_encrypted
    s.send(ike_create_child_sa)

    while True:
        ike_create_child_sa_response = s.recv()
        if ike_create_child_sa_response is None or ike_create_child_sa_response[Ether].src == src_mac:
            continue
        # elif ike_create_child_sa_response[IP].proto == 17 and ike_create_child_sa_response[UDP].sport == 500 and ike_create_child_sa_response.init_SPI == ike_spi_i :
        elif ike_create_child_sa_response.haslayer("IKEv2") and ike_create_child_sa_response.init_SPI == ike_spi_i and ike_create_child_sa_response.exch_type == 0x24:
            init_vector_r   = ike_create_child_sa_response[IKEv2_payload_Encrypted].iv
            des3_decrypt = DES3.new(SK_er, DES3.MODE_CBC, init_vector_r)
            decrypted_data = des3_decrypt.decrypt((ike_create_child_sa_response[IKEv2_payload_Encrypted].load)[:-12])
            # ikev2_payload_decrypted = IKEv2_payload_Decrypted(next_payload=IKEv2_payload_type.index('SA'))
            # ikev2_payload_decrypted /= decrypted_data
            # print "line %d: ikev2_payload_decrypted is \n%s" % (lineno(), toHex(str(ikev2_payload_decrypted)))
            ikev2_payload_decrypted = dissert_ikev2_decrypted_payload('SA', decrypted_data)
            print "line %d: ikev2_payload_decrypted is \n%s" % (lineno(), toHex(str(ikev2_payload_decrypted)))
            # print "line %d: ipsec_spi_r is %s" %(lineno(), toHex(ikev2_payload_decrypted[IKEv2_payload_Proposal].SPI))
            ikev2_payload_decrypted.show2()

            ipsec_spi_r = ikev2_payload_decrypted[IKEv2_payload_Proposal].SPI
            ipsec_nonce_r = ikev2_payload_decrypted[IKEv2_payload_Nonce].load
            break

    return (ipsec_spi_i, ipsec_spi_r, ipsec_nonce_i, ipsec_nonce_r)

def gen_create_child_sa_for_rekey_ike(ya, ike_spi_i, ike_spi_r, SK_ai, SK_ei):
    global ike_message_id
    ike_create_child_sa = Ether()/IP()
    ike_create_child_sa[Ether].src = src_mac
    ike_create_child_sa[Ether].dst = dst_mac
    ike_create_child_sa[IP].src = src_ip
    ike_create_child_sa[IP].dst = dst_ip
    udp = UDP(sport = 500, dport = 500)
    ike_create_child_sa /= udp

    ikev2 = IKEv2()
    # ikev2.init_SPI = ''.join(RandString(8))
    ikev2.init_SPI = ike_spi_i
    ikev2.resp_SPI = ike_spi_r

    #ikev2.resp_SPI = 0
    ikev2.next_payload = IKEv2_payload_type.index("Encrypted")
    ikev2.version = 0x20
    ikev2.exch_type = IKEv2_exchange_type.index("CREATE_CHILD_SA")
    # ikev2.exch_type = IKEv2_exchange_type.index("IKE_AUTH")
    ikev2.flags = 0x08
    # ikev2.id = 0x00000001
    # ike_message_id = 0x00
    ikev2.id     = ike_message_id
    ike_message_id += 1

    init_vector = ''.join(RandString(8))

    # packet = rdpcap("./ya yb xa xb p g.pcap")
    # ikev2 = packet[0][IKEv2]
    # ike_nonce_r = toStr('a80650192ca5a6b44159e69078a1449a84a17ae0beb4a7bf5d77cb7c3f174620')

    #construct payload transform and proposal
    ikev2_payload_transform_encryption = IKEv2_payload_Transform()
    ikev2_payload_transform_encryption.next_payload = 0x03
    ikev2_payload_transform_encryption.transform_type = 0x01   #encryption
    ikev2_payload_transform_encryption.transform_id = 0x0003     #3des

    ikev2_payload_transform_integrity = IKEv2_payload_Transform()
    ikev2_payload_transform_integrity.next_payload = 0x03
    ikev2_payload_transform_integrity.transform_type = 0x03     #integrity
    ikev2_payload_transform_integrity.transform_id = 0x0002

    ikev2_payload_transform_prf = IKEv2_payload_Transform()
    ikev2_payload_transform_prf.next_payload = 0x03
    ikev2_payload_transform_prf.transform_type = 0x02           #prf
    ikev2_payload_transform_prf.transform_id = 0x002

    ikev2_payload_transform_dhgroup = IKEv2_payload_Transform()
    ikev2_payload_transform_dhgroup.next_payload = 0x00         #no next payload in transform
    ikev2_payload_transform_dhgroup.transform_type = 0x04       #dh group
    ikev2_payload_transform_dhgroup.transform_id = 0x002

    #construct payload proposal
    ikev2_payload_proposal = IKEv2_payload_Proposal()
    ikev2_payload_proposal.next_payload = 0x0
    ike_spi_i = ''.join(RandString(8))
    ikev2_payload_proposal.SPIsize = 0x08
    ikev2_payload_proposal.SPI = ike_spi_i
    ikev2_payload_proposal.trans_nb = 0x04      #the number of transform
    ikev2_payload_proposal.trans = ikev2_payload_transform_encryption/ikev2_payload_transform_integrity/ikev2_payload_transform_prf/ikev2_payload_transform_dhgroup

    ikev2_payload_sa = IKEv2_payload_SA()
    ikev2_payload_sa.next_payload = 0x22        #next payload is key exchange
    # ikev2_payload_sa.next_payload = 0x00          #next payload is key exchange
    ikev2_payload_sa.prop = ikev2_payload_proposal
    ikev2_payload_sa.show2()
    hexdump(ikev2_payload_sa)

    #construct payload key exchange
    ikev2_payload_ke = IKEv2_payload_KE()
    ikev2_payload_ke.next_payload = 0x28        #next payload is nonce
    ikev2_payload_ke.group = 0x0002             #1024-bit MODP group
    ikev2_payload_ke.load = toStr(ya.digits(16))

    #construct payload nonce
    ikev2_payload_nonce = IKEv2_payload_Nonce()
    ikev2_payload_nonce.next_payload = 0x00     #no more payload
    ike_nonce_i = ''.join(RandString(32))
    ikev2_payload_nonce.load = ike_nonce_i

    plain_data = str(ikev2_payload_sa)+str(ikev2_payload_ke)+str(ikev2_payload_nonce)
    # plain_data = str(ikev2_payload_sa)

    ike_padding = ''
    ike_pad_len = 0
    if (len(plain_data) + 1)%8 == 0:
        ike_padding = '\x00'
    else:
        ike_pad_len = ((len(plain_data) + 1)/8 + 1 )*8 - (len(plain_data) + 1)
        ike_padding = ''.join(randstring(ike_pad_len)) + chr(ike_pad_len)

    plain_data += ike_padding
    
    print "line %d: plain_data is \n%s" % (lineno(), toHex(plain_data))
    des3_encrypt = DES3.new(SK_ei, DES3.MODE_CBC, init_vector)
    encrypted_data = des3_encrypt.encrypt(plain_data)
    print "line %d: encrypted_data is \n%s" % (lineno(), toHex(encrypted_data))


    ikev2_payload_encrypted = IKEv2_payload_Encrypted()
    ikev2_payload_encrypted.next_payload = IKEv2_payload_type.index('SA')  #next payload is Identification - Initiator
    ikev2_payload_encrypted.res  = 0x00         #reserved
    ikev2_payload_encrypted.iv   = init_vector  #initialation vector
    ikev2_payload_encrypted.load = encrypted_data + '\x00'*12   #first padding the integrity checksum data with '\x00'*12
    # ikev2_payload_encrypted.load = encrypted_data + toStr(hmac_result)  #it contains encryted data and integrity checksum data

    hmac_key = SK_ai
    hmac_data = str(ikev2/ikev2_payload_encrypted)[:-12]
    hmac = HMAC.new(hmac_key, msg = hmac_data, digestmod = SHA)
    hmac_result = hmac.hexdigest()[:24]
    print "line %d: hmac_result is \n%s" % (lineno(), (hmac_result))
    ikev2_payload_encrypted.load = encrypted_data + toStr(hmac_result)

    print "line %d: SK_ei is \n%s" %(lineno(), toHex(SK_ei))
    print "line %d: SK_ai is \n%s" %(lineno(), toHex(SK_ai))

    ike_create_child_sa /= ikev2/ikev2_payload_encrypted
    s.send(ike_create_child_sa)
    
    while True:
        ike_create_child_sa_response = s.recv()
        if ike_create_child_sa_response is None or ike_create_child_sa_response[Ether].src == src_mac:
            continue
        #elif ike_create_child_sa_response[IP].proto == 17 and ike_create_child_sa_response[UDP].sport == 500 and ike_create_child_sa_response.init_SPI == ike_spi_i_ori and ike_create_child_sa_response.exch_type == 0x24:
        elif ike_create_child_sa_response.haslayer("IKEv2") and ike_create_child_sa_response.init_SPI == ike_spi_i_ori and ike_create_child_sa_response.exch_type == 0x24:
            init_vector_r   = ike_create_child_sa_response[IKEv2_payload_Encrypted].iv
            des3_decrypt = DES3.new(SK_er, DES3.MODE_CBC, init_vector_r)
            decrypted_data = des3_decrypt.decrypt((ike_create_child_sa_response[IKEv2_payload_Encrypted].load)[:-12])
            ikev2_payload_decrypted = dissert_ikev2_decrypted_payload('SA', decrypted_data)

            ike_spi_r     = ikev2_payload_decrypted[IKEv2_payload_Proposal].SPI
            ike_nonce_r = ikev2_payload_decrypted[IKEv2_payload_Nonce].load
            yb             = ikev2_payload_decrypted[IKEv2_payload_KE].load
            break
    
    return (yb, ike_spi_i, ike_spi_r, ike_nonce_i, ike_nonce_r)


ipsec_nonce_i = ike_nonce_i
ipsec_nonce_r = ike_nonce_r
(SK_ai_ipsec, SK_ar_ipsec, SK_ei_ipsec, SK_er_ipsec) = gen_ipsec_key(ipsec_nonce_i, ipsec_nonce_r)
save_keys_log(ike_spi_i, ike_spi_r, SK_ai, SK_ar, SK_ei, SK_er, SK_ai_ipsec, SK_ar_ipsec, SK_ei_ipsec, SK_er_ipsec)

test_rekey_ipsec = True
if test_rekey_ipsec:
    for iter in xrange(1, 2):
        #Example: encrypt packet
        ether = Ether(src = src_mac, dst = dst_mac, type = 0x0800)
        icmp    = IP(src = traffic_selector_local_ip, dst = traffic_selector_remote_ip, id = 0x0000, flags = 0x02)/ICMP(type=0x08, id = 0x0766, seq = 0x01)/('A'*40)
        esp_seq = 1
        pad_str = payload_padding(len(icmp))
        pad_len = len(pad_str)
        encrypted_icmp = ether/IP(src = src_ip, dst = dst_ip, id = 0x0000, flags = 0x02)/ESP(spi = int(toHex(ipsec_spi_r), 16), seq = esp_seq, iv = toStr('92bffc192af49168'), nh = 0x04, pad = pad_str, padlen = pad_len)/icmp
        s.send(encrypted_icmp)

        ipsec_spi_i_ori = ipsec_spi_i
        (ipsec_spi_i, ipsec_spi_r, ipsec_nonce_i, ipsec_nonce_r)     = gen_create_child__sa_for_rekey_ipsec(ipsec_spi_i, SK_ai, SK_ar, SK_ei, SK_er)

        del_ipsec_sa(ike_spi_i, ike_spi_r, ipsec_spi_i_ori, SK_ai, SK_ei)    #note: delete original ipsec spi, so the parameter is ipsec_spi_i_ori, not ipsec_spi_i

        (SK_ai_ipsec, SK_ar_ipsec, SK_ei_ipsec, SK_er_ipsec) = gen_ipsec_key(ipsec_nonce_i, ipsec_nonce_r)
        save_keys_log(ike_spi_i, ike_spi_r, SK_ai, SK_ar, SK_ei, SK_er, SK_ai_ipsec, SK_ar_ipsec, SK_ei_ipsec, SK_er_ipsec)


'''Example: encrypt packet'''
ether = Ether(src = src_mac, dst = dst_mac, type = 0x0800)
icmp    = IP(src = traffic_selector_local_ip, dst = traffic_selector_remote_ip, id = 0x0000, flags = 0x02)/ICMP(type=0x08, id = 0x0766, seq = 0x01)/('A'*40)
esp_seq = 1
pad_str = payload_padding(len(icmp))
pad_len = len(pad_str)
encrypted_icmp = ether/IP(src = src_ip, dst = dst_ip, id = 0x0000, flags = 0x02)/ESP(spi = int(toHex(ipsec_spi_r), 16), seq = esp_seq, iv = toStr('92bffc192af49168'), nh = 0x04, pad = pad_str, padlen = pad_len)/icmp
s.send(encrypted_icmp)

# time.sleep(15)
del_ipsec_sa(ike_spi_i, ike_spi_r, ipsec_spi_i, SK_ai, SK_ei)
time.sleep(1)

# exit()
ike_spi_i_ori = ike_spi_i
ike_spi_r_ori = ike_spi_r
test_rekey_ike = True
if test_rekey_ike:
    for i in xrange(1,2):
        ike_spi_i_ori = ike_spi_i
        ike_spi_r_ori = ike_spi_r
        (yb, ike_spi_i, ike_spi_r, ike_nonce_i, ike_nonce_r)     = gen_create_child_sa_for_rekey_ike(ya, ike_spi_i, ike_spi_r, SK_ai, SK_ei)
        del_ike_sa(ike_spi_i_ori, ike_spi_r_ori, SK_ai, SK_ei)
        SK_d_ori = SK_d
        (SK_d, SK_ai, SK_ar, SK_ei, SK_er, SK_pi, SK_pr) = regen_ike_key(xa, yb, SK_d, ike_nonce_i, ike_nonce_r, ike_spi_i, ike_spi_r)
        save_keys_log(ike_spi_i, ike_spi_r, SK_ai, SK_ar, SK_ei, SK_er, SK_ai_ipsec, SK_ar_ipsec, SK_ei_ipsec, SK_er_ipsec)
        ike_message_id = 0

# (yb, ike_spi_i, ike_spi_r, ike_nonce_i, ike_nonce_r)     = gen_create_child_sa_for_rekey_ike(ya, ike_spi_i, ike_spi_r, SK_ai, SK_ei)

# del_ike_sa(ike_spi_i_ori, ike_spi_r_ori, SK_ai, SK_ei)
# SK_d_ori = SK_d
# (SK_d, SK_ai, SK_ar, SK_ei, SK_er, SK_pi, SK_pr) = regen_ike_key(xa, yb, SK_d, ike_nonce_i, ike_nonce_r, ike_spi_i, ike_spi_r)
# save_keys_log(ike_spi_i, ike_spi_r, SK_ai, SK_ar, SK_ei, SK_er, SK_ai_ipsec, SK_ar_ipsec, SK_ei_ipsec, SK_er_ipsec)
ike_message_id = 0
# time.sleep(5)
del_ike_sa(ike_spi_i, ike_spi_r, SK_ai, SK_ei)

timeout = 2                             #the unit is second
last_time = time.time()

while True:
    esp_recv = s.recv()                 #all former packets sended by function sendp(encrypted_icmps) can be captured in here
    # print time.time()
    # print "Its been %f seconds" % (time.time() - last_time)
    if  time.time() - last_time > timeout:
        print "line %d: timeout" % (lineno())
        break
    #if esp_recv is None or esp_recv[Ether].src == src_mac:
    if esp_recv is None or esp_recv[Ether].type != 0x0800 :      #here esp_recv[IP].src cause the packet esp_recv does post_dissert process
        continue
        # if esp_recv[IP].proto == 50:
            # break;
    elif esp_recv[IP].proto == 50:
        last_time = time.time()
        # esp_recv.show2()
        print "line %d: length of is ESP.decrypted_packets %d" %(lineno(), len(ESP.decrypted_packets))


'''Save the decrypted the ESP packets'''
dumped_file_dir = "C:\\Scapy Log\\"
if not os.path.exists(dumped_file_dir):
    os.mkdir(dumped_file_dir)

dumped_filename = "%s.pcap" % (datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S"))
print "line %d: dumped_filename is %s" % (lineno(), dumped_filename)
dumped_filename = dumped_file_dir + "\\" + dumped_filename

print "line %d: length of is ESP.decrypted_packets %d" %(lineno(), len(ESP.decrypted_packets))

# ESP.decrypted_packets.extend(encrypted_icmps[0])

if len(ESP.decrypted_packets) != 0:
    wrpcap(dumped_filename, ESP.decrypted_packets)
    print "line %d: write %d packets in %s" %(lineno(), len(ESP.decrypted_packets), dumped_filename)
else:
    print "line %d: No ESP decrypted_packets" % (lineno())

exit()